<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# ast

```go
import "github.com/dev-kas/virtlang-go/v4/ast"
```

## Index

- [type ArrayLiteral](<#ArrayLiteral>)
  - [func \(o \*ArrayLiteral\) GetSourceMetadata\(\) SourceMetadata](<#ArrayLiteral.GetSourceMetadata>)
  - [func \(o \*ArrayLiteral\) GetType\(\) NodeType](<#ArrayLiteral.GetType>)
- [type BinaryExpr](<#BinaryExpr>)
  - [func \(b \*BinaryExpr\) GetSourceMetadata\(\) SourceMetadata](<#BinaryExpr.GetSourceMetadata>)
  - [func \(b \*BinaryExpr\) GetType\(\) NodeType](<#BinaryExpr.GetType>)
- [type BinaryOperator](<#BinaryOperator>)
- [type BreakStmt](<#BreakStmt>)
  - [func \(r \*BreakStmt\) GetSourceMetadata\(\) SourceMetadata](<#BreakStmt.GetSourceMetadata>)
  - [func \(r \*BreakStmt\) GetType\(\) NodeType](<#BreakStmt.GetType>)
- [type CallExpr](<#CallExpr>)
  - [func \(c \*CallExpr\) GetSourceMetadata\(\) SourceMetadata](<#CallExpr.GetSourceMetadata>)
  - [func \(c \*CallExpr\) GetType\(\) NodeType](<#CallExpr.GetType>)
- [type Class](<#Class>)
  - [func \(c \*Class\) GetSourceMetadata\(\) SourceMetadata](<#Class.GetSourceMetadata>)
  - [func \(c \*Class\) GetType\(\) NodeType](<#Class.GetType>)
- [type ClassMethod](<#ClassMethod>)
  - [func \(c \*ClassMethod\) GetSourceMetadata\(\) SourceMetadata](<#ClassMethod.GetSourceMetadata>)
  - [func \(c \*ClassMethod\) GetType\(\) NodeType](<#ClassMethod.GetType>)
- [type ClassProperty](<#ClassProperty>)
  - [func \(c \*ClassProperty\) GetSourceMetadata\(\) SourceMetadata](<#ClassProperty.GetSourceMetadata>)
  - [func \(c \*ClassProperty\) GetType\(\) NodeType](<#ClassProperty.GetType>)
- [type CompareExpr](<#CompareExpr>)
  - [func \(c \*CompareExpr\) GetSourceMetadata\(\) SourceMetadata](<#CompareExpr.GetSourceMetadata>)
  - [func \(c \*CompareExpr\) GetType\(\) NodeType](<#CompareExpr.GetType>)
- [type CompareOperator](<#CompareOperator>)
- [type ContinueStmt](<#ContinueStmt>)
  - [func \(r \*ContinueStmt\) GetSourceMetadata\(\) SourceMetadata](<#ContinueStmt.GetSourceMetadata>)
  - [func \(r \*ContinueStmt\) GetType\(\) NodeType](<#ContinueStmt.GetType>)
- [type Expr](<#Expr>)
- [type FnDeclaration](<#FnDeclaration>)
  - [func \(f \*FnDeclaration\) GetSourceMetadata\(\) SourceMetadata](<#FnDeclaration.GetSourceMetadata>)
  - [func \(f \*FnDeclaration\) GetType\(\) NodeType](<#FnDeclaration.GetType>)
- [type Identifier](<#Identifier>)
  - [func \(i \*Identifier\) GetSourceMetadata\(\) SourceMetadata](<#Identifier.GetSourceMetadata>)
  - [func \(i \*Identifier\) GetType\(\) NodeType](<#Identifier.GetType>)
- [type IfStatement](<#IfStatement>)
  - [func \(i \*IfStatement\) GetSourceMetadata\(\) SourceMetadata](<#IfStatement.GetSourceMetadata>)
  - [func \(i \*IfStatement\) GetType\(\) NodeType](<#IfStatement.GetType>)
- [type LogicalExpr](<#LogicalExpr>)
  - [func \(l \*LogicalExpr\) GetSourceMetadata\(\) SourceMetadata](<#LogicalExpr.GetSourceMetadata>)
  - [func \(l \*LogicalExpr\) GetType\(\) NodeType](<#LogicalExpr.GetType>)
- [type LogicalOperator](<#LogicalOperator>)
- [type MemberExpr](<#MemberExpr>)
  - [func \(m \*MemberExpr\) GetSourceMetadata\(\) SourceMetadata](<#MemberExpr.GetSourceMetadata>)
  - [func \(m \*MemberExpr\) GetType\(\) NodeType](<#MemberExpr.GetType>)
- [type NodeType](<#NodeType>)
  - [func \(n NodeType\) String\(\) string](<#NodeType.String>)
- [type NumericLiteral](<#NumericLiteral>)
  - [func \(n \*NumericLiteral\) GetSourceMetadata\(\) SourceMetadata](<#NumericLiteral.GetSourceMetadata>)
  - [func \(n \*NumericLiteral\) GetType\(\) NodeType](<#NumericLiteral.GetType>)
- [type ObjectLiteral](<#ObjectLiteral>)
  - [func \(o \*ObjectLiteral\) GetSourceMetadata\(\) SourceMetadata](<#ObjectLiteral.GetSourceMetadata>)
  - [func \(o \*ObjectLiteral\) GetType\(\) NodeType](<#ObjectLiteral.GetType>)
- [type Program](<#Program>)
  - [func \(p \*Program\) GetSourceMetadata\(\) SourceMetadata](<#Program.GetSourceMetadata>)
  - [func \(p \*Program\) GetType\(\) NodeType](<#Program.GetType>)
- [type Property](<#Property>)
  - [func \(p \*Property\) GetSourceMetadata\(\) SourceMetadata](<#Property.GetSourceMetadata>)
  - [func \(p \*Property\) GetType\(\) NodeType](<#Property.GetType>)
- [type ReturnStmt](<#ReturnStmt>)
  - [func \(r \*ReturnStmt\) GetSourceMetadata\(\) SourceMetadata](<#ReturnStmt.GetSourceMetadata>)
  - [func \(r \*ReturnStmt\) GetType\(\) NodeType](<#ReturnStmt.GetType>)
- [type SourceMetadata](<#SourceMetadata>)
- [type Stmt](<#Stmt>)
- [type StringLiteral](<#StringLiteral>)
  - [func \(s \*StringLiteral\) GetSourceMetadata\(\) SourceMetadata](<#StringLiteral.GetSourceMetadata>)
  - [func \(s \*StringLiteral\) GetType\(\) NodeType](<#StringLiteral.GetType>)
- [type TryCatchStmt](<#TryCatchStmt>)
  - [func \(t \*TryCatchStmt\) GetSourceMetadata\(\) SourceMetadata](<#TryCatchStmt.GetSourceMetadata>)
  - [func \(t \*TryCatchStmt\) GetType\(\) NodeType](<#TryCatchStmt.GetType>)
- [type VarAssignmentExpr](<#VarAssignmentExpr>)
  - [func \(v \*VarAssignmentExpr\) GetSourceMetadata\(\) SourceMetadata](<#VarAssignmentExpr.GetSourceMetadata>)
  - [func \(v \*VarAssignmentExpr\) GetType\(\) NodeType](<#VarAssignmentExpr.GetType>)
- [type VarDeclaration](<#VarDeclaration>)
  - [func \(v \*VarDeclaration\) GetSourceMetadata\(\) SourceMetadata](<#VarDeclaration.GetSourceMetadata>)
  - [func \(v \*VarDeclaration\) GetType\(\) NodeType](<#VarDeclaration.GetType>)
- [type WhileLoop](<#WhileLoop>)
  - [func \(w \*WhileLoop\) GetSourceMetadata\(\) SourceMetadata](<#WhileLoop.GetSourceMetadata>)
  - [func \(w \*WhileLoop\) GetType\(\) NodeType](<#WhileLoop.GetType>)


<a name="ArrayLiteral"></a>
## type ArrayLiteral



```go
type ArrayLiteral struct {
    Elements []Expr
    SourceMetadata
}
```

<a name="ArrayLiteral.GetSourceMetadata"></a>
### func \(\*ArrayLiteral\) GetSourceMetadata

```go
func (o *ArrayLiteral) GetSourceMetadata() SourceMetadata
```



<a name="ArrayLiteral.GetType"></a>
### func \(\*ArrayLiteral\) GetType

```go
func (o *ArrayLiteral) GetType() NodeType
```



<a name="BinaryExpr"></a>
## type BinaryExpr



```go
type BinaryExpr struct {
    LHS      Expr
    RHS      Expr
    Operator BinaryOperator
    SourceMetadata
}
```

<a name="BinaryExpr.GetSourceMetadata"></a>
### func \(\*BinaryExpr\) GetSourceMetadata

```go
func (b *BinaryExpr) GetSourceMetadata() SourceMetadata
```



<a name="BinaryExpr.GetType"></a>
### func \(\*BinaryExpr\) GetType

```go
func (b *BinaryExpr) GetType() NodeType
```



<a name="BinaryOperator"></a>
## type BinaryOperator



```go
type BinaryOperator string
```

<a name="Plus"></a>

```go
const (
    Plus     BinaryOperator = "+"
    Minus    BinaryOperator = "-"
    Multiply BinaryOperator = "*"
    Divide   BinaryOperator = "/"
    Modulo   BinaryOperator = "%"
)
```

<a name="BreakStmt"></a>
## type BreakStmt



```go
type BreakStmt struct {
    SourceMetadata
}
```

<a name="BreakStmt.GetSourceMetadata"></a>
### func \(\*BreakStmt\) GetSourceMetadata

```go
func (r *BreakStmt) GetSourceMetadata() SourceMetadata
```



<a name="BreakStmt.GetType"></a>
### func \(\*BreakStmt\) GetType

```go
func (r *BreakStmt) GetType() NodeType
```



<a name="CallExpr"></a>
## type CallExpr



```go
type CallExpr struct {
    Args   []Expr
    Callee Expr
    SourceMetadata
}
```

<a name="CallExpr.GetSourceMetadata"></a>
### func \(\*CallExpr\) GetSourceMetadata

```go
func (c *CallExpr) GetSourceMetadata() SourceMetadata
```



<a name="CallExpr.GetType"></a>
### func \(\*CallExpr\) GetType

```go
func (c *CallExpr) GetType() NodeType
```



<a name="Class"></a>
## type Class



```go
type Class struct {
    Name        string
    Body        []Stmt
    Constructor *ClassMethod
    SourceMetadata
}
```

<a name="Class.GetSourceMetadata"></a>
### func \(\*Class\) GetSourceMetadata

```go
func (c *Class) GetSourceMetadata() SourceMetadata
```



<a name="Class.GetType"></a>
### func \(\*Class\) GetType

```go
func (c *Class) GetType() NodeType
```



<a name="ClassMethod"></a>
## type ClassMethod



```go
type ClassMethod struct {
    Name     string
    Body     []Stmt
    Params   []string
    IsPublic bool
    SourceMetadata
}
```

<a name="ClassMethod.GetSourceMetadata"></a>
### func \(\*ClassMethod\) GetSourceMetadata

```go
func (c *ClassMethod) GetSourceMetadata() SourceMetadata
```



<a name="ClassMethod.GetType"></a>
### func \(\*ClassMethod\) GetType

```go
func (c *ClassMethod) GetType() NodeType
```



<a name="ClassProperty"></a>
## type ClassProperty



```go
type ClassProperty struct {
    Name     string
    Value    Expr
    IsPublic bool
    SourceMetadata
}
```

<a name="ClassProperty.GetSourceMetadata"></a>
### func \(\*ClassProperty\) GetSourceMetadata

```go
func (c *ClassProperty) GetSourceMetadata() SourceMetadata
```



<a name="ClassProperty.GetType"></a>
### func \(\*ClassProperty\) GetType

```go
func (c *ClassProperty) GetType() NodeType
```



<a name="CompareExpr"></a>
## type CompareExpr



```go
type CompareExpr struct {
    LHS      Expr
    RHS      Expr
    Operator CompareOperator
    SourceMetadata
}
```

<a name="CompareExpr.GetSourceMetadata"></a>
### func \(\*CompareExpr\) GetSourceMetadata

```go
func (c *CompareExpr) GetSourceMetadata() SourceMetadata
```



<a name="CompareExpr.GetType"></a>
### func \(\*CompareExpr\) GetType

```go
func (c *CompareExpr) GetType() NodeType
```



<a name="CompareOperator"></a>
## type CompareOperator



```go
type CompareOperator string
```

<a name="LessThanEqual"></a>

```go
const (
    LessThanEqual    CompareOperator = "<="
    LessThan         CompareOperator = "<"
    GreaterThanEqual CompareOperator = ">="
    GreaterThan      CompareOperator = ">"
    Equal            CompareOperator = "=="
    NotEqual         CompareOperator = "!="
)
```

<a name="ContinueStmt"></a>
## type ContinueStmt



```go
type ContinueStmt struct {
    SourceMetadata
}
```

<a name="ContinueStmt.GetSourceMetadata"></a>
### func \(\*ContinueStmt\) GetSourceMetadata

```go
func (r *ContinueStmt) GetSourceMetadata() SourceMetadata
```



<a name="ContinueStmt.GetType"></a>
### func \(\*ContinueStmt\) GetType

```go
func (r *ContinueStmt) GetType() NodeType
```



<a name="Expr"></a>
## type Expr



```go
type Expr interface {
    GetType() NodeType
    GetSourceMetadata() SourceMetadata
}
```

<a name="FnDeclaration"></a>
## type FnDeclaration



```go
type FnDeclaration struct {
    Params    []string
    Name      string
    Body      []Stmt
    Anonymous bool
    SourceMetadata
}
```

<a name="FnDeclaration.GetSourceMetadata"></a>
### func \(\*FnDeclaration\) GetSourceMetadata

```go
func (f *FnDeclaration) GetSourceMetadata() SourceMetadata
```



<a name="FnDeclaration.GetType"></a>
### func \(\*FnDeclaration\) GetType

```go
func (f *FnDeclaration) GetType() NodeType
```



<a name="Identifier"></a>
## type Identifier



```go
type Identifier struct {
    Symbol string
    SourceMetadata
}
```

<a name="Identifier.GetSourceMetadata"></a>
### func \(\*Identifier\) GetSourceMetadata

```go
func (i *Identifier) GetSourceMetadata() SourceMetadata
```



<a name="Identifier.GetType"></a>
### func \(\*Identifier\) GetType

```go
func (i *Identifier) GetType() NodeType
```



<a name="IfStatement"></a>
## type IfStatement



```go
type IfStatement struct {
    Body      []Stmt
    Condition Expr
    Else      []Stmt         // Optional else block
    ElseIf    []*IfStatement // Optional else-if branches
    SourceMetadata
}
```

<a name="IfStatement.GetSourceMetadata"></a>
### func \(\*IfStatement\) GetSourceMetadata

```go
func (i *IfStatement) GetSourceMetadata() SourceMetadata
```



<a name="IfStatement.GetType"></a>
### func \(\*IfStatement\) GetType

```go
func (i *IfStatement) GetType() NodeType
```



<a name="LogicalExpr"></a>
## type LogicalExpr



```go
type LogicalExpr struct {
    LHS      *Expr // Optional LHS for unary operators
    RHS      Expr
    Operator LogicalOperator
    SourceMetadata
}
```

<a name="LogicalExpr.GetSourceMetadata"></a>
### func \(\*LogicalExpr\) GetSourceMetadata

```go
func (l *LogicalExpr) GetSourceMetadata() SourceMetadata
```



<a name="LogicalExpr.GetType"></a>
### func \(\*LogicalExpr\) GetType

```go
func (l *LogicalExpr) GetType() NodeType
```



<a name="LogicalOperator"></a>
## type LogicalOperator



```go
type LogicalOperator string
```

<a name="LogicalAND"></a>

```go
const (
    LogicalAND           LogicalOperator = "&&"
    LogicalOR            LogicalOperator = "||"
    LogicalNilCoalescing LogicalOperator = "??"
    LogicalNOT           LogicalOperator = "!"
)
```

<a name="MemberExpr"></a>
## type MemberExpr



```go
type MemberExpr struct {
    Object   Expr
    Value    Expr
    Computed bool
    SourceMetadata
}
```

<a name="MemberExpr.GetSourceMetadata"></a>
### func \(\*MemberExpr\) GetSourceMetadata

```go
func (m *MemberExpr) GetSourceMetadata() SourceMetadata
```



<a name="MemberExpr.GetType"></a>
### func \(\*MemberExpr\) GetType

```go
func (m *MemberExpr) GetType() NodeType
```



<a name="NodeType"></a>
## type NodeType



```go
type NodeType int
```

<a name="ProgramNode"></a>

```go
const (
    ProgramNode NodeType = iota
    VarDeclarationNode
    FnDeclarationNode
    IfStatementNode
    ClassNode
    ClassMethodNode
    ClassPropertyNode
    WhileLoopNode
    VarAssignmentExprNode
    TryCatchStmtNode
    MemberExprNode
    ReturnStmtNode
    BreakStmtNode
    ContinueStmtNode
    CallExprNode
    PropertyNode
    ObjectLiteralNode
    ArrayLiteralNode
    NumericLiteralNode
    StringLiteralNode
    IdentifierNode
    CompareExprNode
    BinaryExprNode
    LogicalExprNode
)
```

<a name="NodeType.String"></a>
### func \(NodeType\) String

```go
func (n NodeType) String() string
```



<a name="NumericLiteral"></a>
## type NumericLiteral



```go
type NumericLiteral struct {
    Value float64
    SourceMetadata
}
```

<a name="NumericLiteral.GetSourceMetadata"></a>
### func \(\*NumericLiteral\) GetSourceMetadata

```go
func (n *NumericLiteral) GetSourceMetadata() SourceMetadata
```



<a name="NumericLiteral.GetType"></a>
### func \(\*NumericLiteral\) GetType

```go
func (n *NumericLiteral) GetType() NodeType
```



<a name="ObjectLiteral"></a>
## type ObjectLiteral



```go
type ObjectLiteral struct {
    Properties []Property
    SourceMetadata
}
```

<a name="ObjectLiteral.GetSourceMetadata"></a>
### func \(\*ObjectLiteral\) GetSourceMetadata

```go
func (o *ObjectLiteral) GetSourceMetadata() SourceMetadata
```



<a name="ObjectLiteral.GetType"></a>
### func \(\*ObjectLiteral\) GetType

```go
func (o *ObjectLiteral) GetType() NodeType
```



<a name="Program"></a>
## type Program



```go
type Program struct {
    Stmts []Stmt
    SourceMetadata
}
```

<a name="Program.GetSourceMetadata"></a>
### func \(\*Program\) GetSourceMetadata

```go
func (p *Program) GetSourceMetadata() SourceMetadata
```



<a name="Program.GetType"></a>
### func \(\*Program\) GetType

```go
func (p *Program) GetType() NodeType
```



<a name="Property"></a>
## type Property



```go
type Property struct {
    Key   string
    Value Expr
    SourceMetadata
}
```

<a name="Property.GetSourceMetadata"></a>
### func \(\*Property\) GetSourceMetadata

```go
func (p *Property) GetSourceMetadata() SourceMetadata
```



<a name="Property.GetType"></a>
### func \(\*Property\) GetType

```go
func (p *Property) GetType() NodeType
```



<a name="ReturnStmt"></a>
## type ReturnStmt



```go
type ReturnStmt struct {
    Value Expr
    SourceMetadata
}
```

<a name="ReturnStmt.GetSourceMetadata"></a>
### func \(\*ReturnStmt\) GetSourceMetadata

```go
func (r *ReturnStmt) GetSourceMetadata() SourceMetadata
```



<a name="ReturnStmt.GetType"></a>
### func \(\*ReturnStmt\) GetType

```go
func (r *ReturnStmt) GetType() NodeType
```



<a name="SourceMetadata"></a>
## type SourceMetadata



```go
type SourceMetadata struct {
    StartLine   int
    StartColumn int
    EndLine     int
    EndColumn   int
    Filename    string
}
```

<a name="Stmt"></a>
## type Stmt



```go
type Stmt interface {
    GetType() NodeType
    GetSourceMetadata() SourceMetadata
}
```

<a name="StringLiteral"></a>
## type StringLiteral



```go
type StringLiteral struct {
    Value string
    SourceMetadata
}
```

<a name="StringLiteral.GetSourceMetadata"></a>
### func \(\*StringLiteral\) GetSourceMetadata

```go
func (s *StringLiteral) GetSourceMetadata() SourceMetadata
```



<a name="StringLiteral.GetType"></a>
### func \(\*StringLiteral\) GetType

```go
func (s *StringLiteral) GetType() NodeType
```



<a name="TryCatchStmt"></a>
## type TryCatchStmt



```go
type TryCatchStmt struct {
    Try      []Stmt
    Catch    []Stmt
    CatchVar string
    SourceMetadata
}
```

<a name="TryCatchStmt.GetSourceMetadata"></a>
### func \(\*TryCatchStmt\) GetSourceMetadata

```go
func (t *TryCatchStmt) GetSourceMetadata() SourceMetadata
```



<a name="TryCatchStmt.GetType"></a>
### func \(\*TryCatchStmt\) GetType

```go
func (t *TryCatchStmt) GetType() NodeType
```



<a name="VarAssignmentExpr"></a>
## type VarAssignmentExpr



```go
type VarAssignmentExpr struct {
    Assignee Expr
    Value    Expr
    SourceMetadata
}
```

<a name="VarAssignmentExpr.GetSourceMetadata"></a>
### func \(\*VarAssignmentExpr\) GetSourceMetadata

```go
func (v *VarAssignmentExpr) GetSourceMetadata() SourceMetadata
```



<a name="VarAssignmentExpr.GetType"></a>
### func \(\*VarAssignmentExpr\) GetType

```go
func (v *VarAssignmentExpr) GetType() NodeType
```



<a name="VarDeclaration"></a>
## type VarDeclaration



```go
type VarDeclaration struct {
    Constant   bool
    Identifier string
    Value      Expr
    SourceMetadata
}
```

<a name="VarDeclaration.GetSourceMetadata"></a>
### func \(\*VarDeclaration\) GetSourceMetadata

```go
func (v *VarDeclaration) GetSourceMetadata() SourceMetadata
```



<a name="VarDeclaration.GetType"></a>
### func \(\*VarDeclaration\) GetType

```go
func (v *VarDeclaration) GetType() NodeType
```



<a name="WhileLoop"></a>
## type WhileLoop



```go
type WhileLoop struct {
    Body      []Stmt
    Condition Expr
    SourceMetadata
}
```

<a name="WhileLoop.GetSourceMetadata"></a>
### func \(\*WhileLoop\) GetSourceMetadata

```go
func (w *WhileLoop) GetSourceMetadata() SourceMetadata
```



<a name="WhileLoop.GetType"></a>
### func \(\*WhileLoop\) GetType

```go
func (w *WhileLoop) GetType() NodeType
```



# debugger

```go
import "github.com/dev-kas/virtlang-go/v4/debugger"
```

## Index

- [Variables](<#variables>)
- [type BreakpointManager](<#BreakpointManager>)
  - [func NewBreakpointManager\(\) \*BreakpointManager](<#NewBreakpointManager>)
  - [func \(bm \*BreakpointManager\) Clear\(\)](<#BreakpointManager.Clear>)
  - [func \(bm \*BreakpointManager\) Has\(file string, line int\) bool](<#BreakpointManager.Has>)
  - [func \(bm \*BreakpointManager\) Remove\(file string, line int\)](<#BreakpointManager.Remove>)
  - [func \(bm \*BreakpointManager\) Set\(file string, line int\)](<#BreakpointManager.Set>)
- [type CallStack](<#CallStack>)
  - [func DeepCopyCallStack\(stack CallStack\) CallStack](<#DeepCopyCallStack>)
- [type Debugger](<#Debugger>)
  - [func NewDebugger\(env \*environment.Environment\) \*Debugger](<#NewDebugger>)
  - [func \(d \*Debugger\) Continue\(\) error](<#Debugger.Continue>)
  - [func \(d \*Debugger\) IsDebuggable\(nodeType ast.NodeType\) bool](<#Debugger.IsDebuggable>)
  - [func \(d \*Debugger\) Pause\(\) error](<#Debugger.Pause>)
  - [func \(d \*Debugger\) PopFrame\(\)](<#Debugger.PopFrame>)
  - [func \(d \*Debugger\) PushFrame\(frame StackFrame\)](<#Debugger.PushFrame>)
  - [func \(d \*Debugger\) ShouldStop\(filename string, line int\) bool](<#Debugger.ShouldStop>)
  - [func \(d \*Debugger\) StepInto\(\) error](<#Debugger.StepInto>)
  - [func \(d \*Debugger\) StepOut\(\) error](<#Debugger.StepOut>)
  - [func \(d \*Debugger\) StepOver\(\) error](<#Debugger.StepOver>)
  - [func \(d \*Debugger\) TakeSnapshot\(\)](<#Debugger.TakeSnapshot>)
  - [func \(d \*Debugger\) WaitIfPaused\(nodeType ast.NodeType\)](<#Debugger.WaitIfPaused>)
- [type Snapshot](<#Snapshot>)
- [type Snapshots](<#Snapshots>)
- [type StackFrame](<#StackFrame>)
- [type State](<#State>)
- [type StepType](<#StepType>)


## Variables

<a name="Debuggables"></a>Define what can be debugged

```go
var Debuggables = map[ast.NodeType]struct{}{
    ast.VarDeclarationNode:    {},
    ast.VarAssignmentExprNode: {},
    ast.IfStatementNode:       {},
    ast.WhileLoopNode:         {},
    ast.ReturnStmtNode:        {},
    ast.ContinueStmtNode:      {},
    ast.BreakStmtNode:         {},
    ast.TryCatchStmtNode:      {},
    ast.CallExprNode:          {},
    ast.FnDeclarationNode:     {},
    ast.ClassNode:             {},
    ast.ClassMethodNode:       {},
    ast.ClassPropertyNode:     {},
    ast.ProgramNode:           {},
}
```

<a name="BreakpointManager"></a>
## type BreakpointManager



```go
type BreakpointManager struct {
    Breakpoints map[string]bool
}
```

<a name="NewBreakpointManager"></a>
### func NewBreakpointManager

```go
func NewBreakpointManager() *BreakpointManager
```



<a name="BreakpointManager.Clear"></a>
### func \(\*BreakpointManager\) Clear

```go
func (bm *BreakpointManager) Clear()
```



<a name="BreakpointManager.Has"></a>
### func \(\*BreakpointManager\) Has

```go
func (bm *BreakpointManager) Has(file string, line int) bool
```



<a name="BreakpointManager.Remove"></a>
### func \(\*BreakpointManager\) Remove

```go
func (bm *BreakpointManager) Remove(file string, line int)
```



<a name="BreakpointManager.Set"></a>
### func \(\*BreakpointManager\) Set

```go
func (bm *BreakpointManager) Set(file string, line int)
```



<a name="CallStack"></a>
## type CallStack



```go
type CallStack []StackFrame
```

<a name="DeepCopyCallStack"></a>
### func DeepCopyCallStack

```go
func DeepCopyCallStack(stack CallStack) CallStack
```

DeepCopyCallStack creates a deep copy of the call stack

<a name="Debugger"></a>
## type Debugger



```go
type Debugger struct {
    BreakpointManager BreakpointManager
    Environment       *environment.Environment
    State             State
    CurrentFile       string
    CurrentLine       int
    CallStack         CallStack
    Snapshots         Snapshots
    // contains filtered or unexported fields
}
```

<a name="NewDebugger"></a>
### func NewDebugger

```go
func NewDebugger(env *environment.Environment) *Debugger
```



<a name="Debugger.Continue"></a>
### func \(\*Debugger\) Continue

```go
func (d *Debugger) Continue() error
```



<a name="Debugger.IsDebuggable"></a>
### func \(\*Debugger\) IsDebuggable

```go
func (d *Debugger) IsDebuggable(nodeType ast.NodeType) bool
```



<a name="Debugger.Pause"></a>
### func \(\*Debugger\) Pause

```go
func (d *Debugger) Pause() error
```



<a name="Debugger.PopFrame"></a>
### func \(\*Debugger\) PopFrame

```go
func (d *Debugger) PopFrame()
```



<a name="Debugger.PushFrame"></a>
### func \(\*Debugger\) PushFrame

```go
func (d *Debugger) PushFrame(frame StackFrame)
```



<a name="Debugger.ShouldStop"></a>
### func \(\*Debugger\) ShouldStop

```go
func (d *Debugger) ShouldStop(filename string, line int) bool
```



<a name="Debugger.StepInto"></a>
### func \(\*Debugger\) StepInto

```go
func (d *Debugger) StepInto() error
```



<a name="Debugger.StepOut"></a>
### func \(\*Debugger\) StepOut

```go
func (d *Debugger) StepOut() error
```



<a name="Debugger.StepOver"></a>
### func \(\*Debugger\) StepOver

```go
func (d *Debugger) StepOver() error
```



<a name="Debugger.TakeSnapshot"></a>
### func \(\*Debugger\) TakeSnapshot

```go
func (d *Debugger) TakeSnapshot()
```



<a name="Debugger.WaitIfPaused"></a>
### func \(\*Debugger\) WaitIfPaused

```go
func (d *Debugger) WaitIfPaused(nodeType ast.NodeType)
```



<a name="Snapshot"></a>
## type Snapshot



```go
type Snapshot struct {
    Stack CallStack
    Env   *environment.Environment
}
```

<a name="Snapshots"></a>
## type Snapshots



```go
type Snapshots []Snapshot
```

<a name="StackFrame"></a>
## type StackFrame



```go
type StackFrame struct {
    Name     string
    Filename string
    Line     int
}
```

<a name="State"></a>
## type State



```go
type State string
```

<a name="RunningState"></a>

```go
const (
    RunningState  State = "running"
    PausedState   State = "paused"
    SteppingState State = "stepping"
)
```

<a name="StepType"></a>
## type StepType



```go
type StepType string
```

<a name="StepInto"></a>

```go
const (
    StepInto StepType = "step_into"
    StepOver StepType = "step_over"
    StepOut  StepType = "step_out"
)
```

# environment

```go
import "github.com/dev-kas/virtlang-go/v4/environment"
```

## Index

- [type Environment](<#Environment>)
  - [func DeepCopy\(env \*Environment\) \*Environment](<#DeepCopy>)
  - [func NewEnvironment\(fork \*Environment\) \*Environment](<#NewEnvironment>)
  - [func \(e \*Environment\) AssignVar\(name string, value shared.RuntimeValue\) \(\*shared.RuntimeValue, \*errors.RuntimeError\)](<#Environment.AssignVar>)
  - [func \(e \*Environment\) DeclareVar\(name string, value shared.RuntimeValue, constant bool\) \(\*shared.RuntimeValue, \*errors.RuntimeError\)](<#Environment.DeclareVar>)
  - [func \(e \*Environment\) LookupVar\(name string\) \(\*shared.RuntimeValue, \*errors.RuntimeError\)](<#Environment.LookupVar>)
  - [func \(e \*Environment\) Resolve\(varname string\) \(\*Environment, \*errors.RuntimeError\)](<#Environment.Resolve>)


<a name="Environment"></a>
## type Environment



```go
type Environment struct {
    Parent    *Environment
    Variables map[string]*shared.RuntimeValue
    Constants map[string]struct{}
    Global    bool
    Mutex     sync.RWMutex
}
```

<a name="DeepCopy"></a>
### func DeepCopy

```go
func DeepCopy(env *Environment) *Environment
```

DeepCopy creates a deep copy of the environment

<a name="NewEnvironment"></a>
### func NewEnvironment

```go
func NewEnvironment(fork *Environment) *Environment
```



<a name="Environment.AssignVar"></a>
### func \(\*Environment\) AssignVar

```go
func (e *Environment) AssignVar(name string, value shared.RuntimeValue) (*shared.RuntimeValue, *errors.RuntimeError)
```



<a name="Environment.DeclareVar"></a>
### func \(\*Environment\) DeclareVar

```go
func (e *Environment) DeclareVar(name string, value shared.RuntimeValue, constant bool) (*shared.RuntimeValue, *errors.RuntimeError)
```



<a name="Environment.LookupVar"></a>
### func \(\*Environment\) LookupVar

```go
func (e *Environment) LookupVar(name string) (*shared.RuntimeValue, *errors.RuntimeError)
```



<a name="Environment.Resolve"></a>
### func \(\*Environment\) Resolve

```go
func (e *Environment) Resolve(varname string) (*Environment, *errors.RuntimeError)
```



# errors

```go
import "github.com/dev-kas/virtlang-go/v4/errors"
```

## Index

- [type InternalCommunicationProtocol](<#InternalCommunicationProtocol>)
- [type InternalCommunicationProtocolTypes](<#InternalCommunicationProtocolTypes>)
- [type LexerError](<#LexerError>)
  - [func NewLexerError\(char rune, pos Position\) \*LexerError](<#NewLexerError>)
  - [func NewLexerErrorf\(pos Position, charForContext rune, format string, args ...interface\{\}\) \*LexerError](<#NewLexerErrorf>)
  - [func \(e \*LexerError\) Error\(\) string](<#LexerError.Error>)
- [type ParserError](<#ParserError>)
  - [func NewParserError\(tokenLiteral string, start, end Position\) \*ParserError](<#NewParserError>)
  - [func NewParserErrorf\(start, end Position, format string, args ...interface\{\}\) \*ParserError](<#NewParserErrorf>)
  - [func \(e \*ParserError\) Error\(\) string](<#ParserError.Error>)
- [type Position](<#Position>)
- [type RuntimeError](<#RuntimeError>)
  - [func \(e \*RuntimeError\) Error\(\) string](<#RuntimeError.Error>)
- [type SyntaxError](<#SyntaxError>)
  - [func NewSyntaxError\(expected string, gotLiteral string, start, end Position\) \*SyntaxError](<#NewSyntaxError>)
  - [func NewSyntaxErrorf\(start, end Position, format string, args ...interface\{\}\) \*SyntaxError](<#NewSyntaxErrorf>)
  - [func \(e \*SyntaxError\) Error\(\) string](<#SyntaxError.Error>)


<a name="InternalCommunicationProtocol"></a>
## type InternalCommunicationProtocol



```go
type InternalCommunicationProtocol struct {
    Type   InternalCommunicationProtocolTypes
    RValue *shared.RuntimeValue
}
```

<a name="InternalCommunicationProtocolTypes"></a>
## type InternalCommunicationProtocolTypes

\-\-\- InternalCommunicationProtocol \-\-\-

```go
type InternalCommunicationProtocolTypes int
```

<a name="ICP_Return"></a>

```go
const (
    ICP_Return InternalCommunicationProtocolTypes = iota
    ICP_Continue
    ICP_Break
)
```

<a name="LexerError"></a>
## type LexerError

\-\-\- LexerError \-\-\-

```go
type LexerError struct {
    Character rune     // The problematic character
    Pos       Position // Position (Line/Col) of the character
    Message   string   // Optional: for specific messages like "unclosed comment"
}
```

<a name="NewLexerError"></a>
### func NewLexerError

```go
func NewLexerError(char rune, pos Position) *LexerError
```

NewLexerError creates a new LexerError for an unexpected character \(Message will be empty\).

<a name="NewLexerErrorf"></a>
### func NewLexerErrorf

```go
func NewLexerErrorf(pos Position, charForContext rune, format string, args ...interface{}) *LexerError
```

NewLexerErrorf creates a new LexerError with a custom message. 'charForContext' can be the opening delimiter \(e.g., '/' for unclosed comment\) or 0 if not relevant. The Message field will be populated by the formatted string.

<a name="LexerError.Error"></a>
### func \(\*LexerError\) Error

```go
func (e *LexerError) Error() string
```



<a name="ParserError"></a>
## type ParserError

\-\-\- ParserError \-\-\- Often, ParserError is very similar to SyntaxError.

```go
type ParserError struct {
    Token   string   // The literal of the unexpected token
    Start   Position // Start position of the token
    End     Position // End position of the token
    Message string   // Optional: More specific message about why it's an error
}
```

<a name="NewParserError"></a>
### func NewParserError

```go
func NewParserError(tokenLiteral string, start, end Position) *ParserError
```

NewParserError creates a new ParserError for an unexpected token.

<a name="NewParserErrorf"></a>
### func NewParserErrorf

```go
func NewParserErrorf(start, end Position, format string, args ...interface{}) *ParserError
```

NewParserErrorf creates a new ParserError with a custom formatted message.

<a name="ParserError.Error"></a>
### func \(\*ParserError\) Error

```go
func (e *ParserError) Error() string
```



<a name="Position"></a>
## type Position



```go
type Position struct {
    Line int // 1-based line number
    Col  int // 1-based column number
}
```

<a name="RuntimeError"></a>
## type RuntimeError

\-\-\- RuntimeError \-\-\-

```go
type RuntimeError struct {
    Message                       string
    InternalCommunicationProtocol *InternalCommunicationProtocol
}
```

<a name="RuntimeError.Error"></a>
### func \(\*RuntimeError\) Error

```go
func (e *RuntimeError) Error() string
```



<a name="SyntaxError"></a>
## type SyntaxError

\-\-\- SyntaxError \-\-\-

```go
type SyntaxError struct {
    Expected string   // What was expected
    Got      string   // What was actually found (e.g., token literal or type)
    Start    Position // Start position of the problematic syntax
    End      Position // End position of the problematic syntax
    Message  string   // Optional additional message
}
```

<a name="NewSyntaxError"></a>
### func NewSyntaxError

```go
func NewSyntaxError(expected string, gotLiteral string, start, end Position) *SyntaxError
```

NewSyntaxError creates a new SyntaxError. 'gotLiteral' is often the token.Literal that caused the error. 'start' and 'end' define the span of the problematic token/syntax.

<a name="NewSyntaxErrorf"></a>
### func NewSyntaxErrorf

```go
func NewSyntaxErrorf(start, end Position, format string, args ...interface{}) *SyntaxError
```

NewSyntaxErrorf creates a new SyntaxError with a custom message.

<a name="SyntaxError.Error"></a>
### func \(\*SyntaxError\) Error

```go
func (e *SyntaxError) Error() string
```



# evaluator

```go
import "github.com/dev-kas/virtlang-go/v4/evaluator"
```

## Index

- [func Evaluate\(astNode ast.Stmt, env \*environment.Environment, dbgr \*debugger.Debugger\) \(\*shared.RuntimeValue, \*errors.RuntimeError\)](<#Evaluate>)


<a name="Evaluate"></a>
## func Evaluate

```go
func Evaluate(astNode ast.Stmt, env *environment.Environment, dbgr *debugger.Debugger) (*shared.RuntimeValue, *errors.RuntimeError)
```

\`dbgr\` circulates the evaluator

# helpers

```go
import "github.com/dev-kas/virtlang-go/v4/helpers"
```

## Index

- [func IsTruthy\(value \*shared.RuntimeValue\) bool](<#IsTruthy>)


<a name="IsTruthy"></a>
## func IsTruthy

```go
func IsTruthy(value *shared.RuntimeValue) bool
```

IsTruthy determines whether a VirtLang RuntimeValue should be considered "truthy" in boolean contexts \(like if statements and while loops\).

Truthiness rules: \- Boolean: true is truthy, false is falsy \- Number: non\-zero is truthy, zero is falsy \- String: non\-empty is truthy, empty is falsy \- Nil: always falsy \- Object: always truthy \(even empty objects\) \- Array: always truthy \(even empty arrays\) \- Function: always truthy \- NativeFN: always truthy \- ClassInstance: always truthy \- Class: always truthy \- Unknown: always truthy

# lexer

```go
import "github.com/dev-kas/virtlang-go/v4/lexer"
```

## Index

- [Variables](<#variables>)
- [func IsAlpha\(r rune\) bool](<#IsAlpha>)
- [func IsAlphaNumeric\(r rune\) bool](<#IsAlphaNumeric>)
- [func IsBinaryOperator\(r rune\) bool](<#IsBinaryOperator>)
- [func IsComparisonOperator\(r string\) bool](<#IsComparisonOperator>)
- [func IsLogicalOperator\(r string\) bool](<#IsLogicalOperator>)
- [func IsNumeric\(r rune\) bool](<#IsNumeric>)
- [func IsSkippable\(r rune\) bool](<#IsSkippable>)
- [func Stringify\(t TokenType\) string](<#Stringify>)
- [func UnescapeString\(s string\) \(string, error\)](<#UnescapeString>)
- [type Token](<#Token>)
  - [func NewToken\(value string, tokenType TokenType, startLine, startCol, endLine, endCol int\) Token](<#NewToken>)
  - [func Tokenize\(srcCode string\) \(\[\]Token, \*errors.LexerError\)](<#Tokenize>)
- [type TokenType](<#TokenType>)


## Variables

<a name="KEYWORDS"></a>

```go
var KEYWORDS = map[string]TokenType{
    "let":      Let,
    "const":    Const,
    "fn":       Fn,
    "if":       If,
    "else":     Else,
    "while":    WhileLoop,
    "try":      Try,
    "catch":    Catch,
    "return":   Return,
    "break":    Break,
    "continue": Continue,
    "class":    Class,
    "public":   Public,
    "private":  Private,
}
```

<a name="REVERSE_KEYWORDS"></a>

```go
var REVERSE_KEYWORDS = make(map[TokenType]string, len(KEYWORDS))
```

<a name="IsAlpha"></a>
## func IsAlpha

```go
func IsAlpha(r rune) bool
```



<a name="IsAlphaNumeric"></a>
## func IsAlphaNumeric

```go
func IsAlphaNumeric(r rune) bool
```



<a name="IsBinaryOperator"></a>
## func IsBinaryOperator

```go
func IsBinaryOperator(r rune) bool
```



<a name="IsComparisonOperator"></a>
## func IsComparisonOperator

```go
func IsComparisonOperator(r string) bool
```



<a name="IsLogicalOperator"></a>
## func IsLogicalOperator

```go
func IsLogicalOperator(r string) bool
```



<a name="IsNumeric"></a>
## func IsNumeric

```go
func IsNumeric(r rune) bool
```



<a name="IsSkippable"></a>
## func IsSkippable

```go
func IsSkippable(r rune) bool
```



<a name="Stringify"></a>
## func Stringify

```go
func Stringify(t TokenType) string
```



<a name="UnescapeString"></a>
## func UnescapeString

```go
func UnescapeString(s string) (string, error)
```



<a name="Token"></a>
## type Token



```go
type Token struct {
    Type      TokenType
    Literal   string
    StartLine int
    StartCol  int
    EndLine   int
    EndCol    int
}
```

<a name="NewToken"></a>
### func NewToken

```go
func NewToken(value string, tokenType TokenType, startLine, startCol, endLine, endCol int) Token
```



<a name="Tokenize"></a>
### func Tokenize

```go
func Tokenize(srcCode string) ([]Token, *errors.LexerError)
```



<a name="TokenType"></a>
## type TokenType



```go
type TokenType int
```

<a name="Number"></a>

```go
const (
    Number          TokenType = iota // 0 - 9
    Identifier                       // a - z A - Z 0 - 9 _ $
    Equals                           // =
    BinOperator                      // / * + _
    OParen                           // (
    CParen                           // )
    Let                              // let
    Const                            // const
    SemiColon                        // ;
    Comma                            // ,
    Colon                            // :
    OBrace                           // {
    CBrace                           // }
    OBracket                         // [
    CBracket                         // ]
    Dot                              // .
    Fn                               // fn
    ComOperator                      // < == > != <= >=
    If                               // if
    Else                             // else
    String                           // '...' "..."
    WhileLoop                        // while
    Comment                          // /*...*/ //...
    Try                              // try
    Catch                            // catch
    Return                           // return
    Break                            // break
    Continue                         // continue
    Class                            // class
    Public                           // public
    Private                          // private
    LogicalOperator                  // && || ?? !
    EOF                              // end of file
)
```

# parser

```go
import "github.com/dev-kas/virtlang-go/v4/parser"
```

## Index

- [type Parser](<#Parser>)
  - [func New\(filename string\) \*Parser](<#New>)
  - [func \(p \*Parser\) ProduceAST\(srcCode string\) \(\*ast.Program, error\)](<#Parser.ProduceAST>)


<a name="Parser"></a>
## type Parser



```go
type Parser struct {
    // contains filtered or unexported fields
}
```

<a name="New"></a>
### func New

```go
func New(filename string) *Parser
```



<a name="Parser.ProduceAST"></a>
### func \(\*Parser\) ProduceAST

```go
func (p *Parser) ProduceAST(srcCode string) (*ast.Program, error)
```



# shared

```go
import "github.com/dev-kas/virtlang-go/v4/shared"
```

## Index

- [func Stringify\(v ValueType\) string](<#Stringify>)
- [type RuntimeValue](<#RuntimeValue>)
- [type ValueType](<#ValueType>)


<a name="Stringify"></a>
## func Stringify

```go
func Stringify(v ValueType) string
```



<a name="RuntimeValue"></a>
## type RuntimeValue



```go
type RuntimeValue struct {
    Type  ValueType
    Value any
}
```

<a name="ValueType"></a>
## type ValueType



```go
type ValueType int
```

<a name="Nil"></a>

```go
const (
    Nil ValueType = iota
    Number
    Boolean
    Object
    Array
    NativeFN
    Function
    String
    Class
    ClassInstance
)
```

# values

```go
import "github.com/dev-kas/virtlang-go/v4/values"
```

## Index

- [func MK\_ARRAY\(value \[\]shared.RuntimeValue\) shared.RuntimeValue](<#MK_ARRAY>)
- [func MK\_BOOL\(value bool\) shared.RuntimeValue](<#MK_BOOL>)
- [func MK\_CLASS\(name string, body \[\]ast.Stmt, constructor \*ast.ClassMethod, declarationEnv \*environment.Environment\) shared.RuntimeValue](<#MK_CLASS>)
- [func MK\_CLASS\_INSTANCE\(class \*ClassValue, publics map\[string\]bool, data \*environment.Environment\) shared.RuntimeValue](<#MK_CLASS_INSTANCE>)
- [func MK\_NATIVE\_FN\(fn NativeFunction\) shared.RuntimeValue](<#MK_NATIVE_FN>)
- [func MK\_NIL\(\) shared.RuntimeValue](<#MK_NIL>)
- [func MK\_NUMBER\(value float64\) shared.RuntimeValue](<#MK_NUMBER>)
- [func MK\_OBJECT\(value map\[string\]\*shared.RuntimeValue\) shared.RuntimeValue](<#MK_OBJECT>)
- [func MK\_STRING\(value string\) shared.RuntimeValue](<#MK_STRING>)
- [type ClassInstanceValue](<#ClassInstanceValue>)
- [type ClassValue](<#ClassValue>)
- [type FunctionValue](<#FunctionValue>)
- [type NativeFunction](<#NativeFunction>)


<a name="MK_ARRAY"></a>
## func MK\_ARRAY

```go
func MK_ARRAY(value []shared.RuntimeValue) shared.RuntimeValue
```



<a name="MK_BOOL"></a>
## func MK\_BOOL

```go
func MK_BOOL(value bool) shared.RuntimeValue
```



<a name="MK_CLASS"></a>
## func MK\_CLASS

```go
func MK_CLASS(name string, body []ast.Stmt, constructor *ast.ClassMethod, declarationEnv *environment.Environment) shared.RuntimeValue
```



<a name="MK_CLASS_INSTANCE"></a>
## func MK\_CLASS\_INSTANCE

```go
func MK_CLASS_INSTANCE(class *ClassValue, publics map[string]bool, data *environment.Environment) shared.RuntimeValue
```



<a name="MK_NATIVE_FN"></a>
## func MK\_NATIVE\_FN

```go
func MK_NATIVE_FN(fn NativeFunction) shared.RuntimeValue
```



<a name="MK_NIL"></a>
## func MK\_NIL

```go
func MK_NIL() shared.RuntimeValue
```



<a name="MK_NUMBER"></a>
## func MK\_NUMBER

```go
func MK_NUMBER(value float64) shared.RuntimeValue
```



<a name="MK_OBJECT"></a>
## func MK\_OBJECT

```go
func MK_OBJECT(value map[string]*shared.RuntimeValue) shared.RuntimeValue
```



<a name="MK_STRING"></a>
## func MK\_STRING

```go
func MK_STRING(value string) shared.RuntimeValue
```



<a name="ClassInstanceValue"></a>
## type ClassInstanceValue



```go
type ClassInstanceValue struct {
    Type    shared.ValueType
    Class   ClassValue
    Publics map[string]bool
    Data    *environment.Environment
}
```

<a name="ClassValue"></a>
## type ClassValue



```go
type ClassValue struct {
    Type           shared.ValueType
    Value          any
    Name           string
    Body           []ast.Stmt
    DeclarationEnv *environment.Environment
    Constructor    *ast.ClassMethod
}
```

<a name="FunctionValue"></a>
## type FunctionValue



```go
type FunctionValue struct {
    Type           shared.ValueType
    Value          any
    Name           string
    Params         []string
    DeclarationEnv *environment.Environment
    Body           []ast.Stmt
}
```

<a name="NativeFunction"></a>
## type NativeFunction



```go
type NativeFunction func(args []shared.RuntimeValue, env *environment.Environment) (*shared.RuntimeValue, *errors.RuntimeError)
```

# testhelpers

```go
import "github.com/dev-kas/virtlang-go/v4/internal/testhelpers"
```

## Index

- [func EvalNode\(t \*testing.T, node ast.Expr\) \*shared.RuntimeValue](<#EvalNode>)
- [func ExpectParseError\(t \*testing.T, src string\)](<#ExpectParseError>)
- [func MustEval\(t \*testing.T, src string\) \*shared.RuntimeValue](<#MustEval>)
- [func MustParse\(t \*testing.T, src string\) \*ast.Program](<#MustParse>)


<a name="EvalNode"></a>
## func EvalNode

```go
func EvalNode(t *testing.T, node ast.Expr) *shared.RuntimeValue
```

EvalNode evaluates a manually constructed AST node directly

<a name="ExpectParseError"></a>
## func ExpectParseError

```go
func ExpectParseError(t *testing.T, src string)
```

ExpectParseError checks that parsing fails for invalid sources

<a name="MustEval"></a>
## func MustEval

```go
func MustEval(t *testing.T, src string) *shared.RuntimeValue
```

MustEval evaluates source code fully \(parse \-\> eval\) and returns the value

<a name="MustParse"></a>
## func MustParse

```go
func MustParse(t *testing.T, src string) *ast.Program
```

MustParse parses source code and returns AST program or fails the test

Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
